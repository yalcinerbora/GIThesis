#version 430
/*	
	**Voxel Deferred Sampled Compute Shader**
	
	File Name	: VoxTraceAO.vert
	Author		: Bora Yalciner
	Description	:

		Instead of tracing camera rays it directly samples deferred depth buffer to
		Sample positions from depth buffer
*/

// Definitions
#define I_OUT_TEXTURE layout(rgba8, binding = 0) restrict

#define LU_SVO_NODE layout(std430, binding = 2) readonly
#define LU_SVO_ILLUM layout(std430, binding = 3) readonly
#define LU_SVO_LEVEL_OFFSET layout(std430, binding = 4) readonly

#define U_RENDER_TYPE layout(location = 0)
#define U_FETCH_LEVEL layout(location = 1)

#define U_FTRANSFORM layout(std140, binding = 0)
#define U_INVFTRANSFORM layout(std140, binding = 1)
#define U_OCTREE_UNIFORMS layout(std140, binding = 3)

#define T_DEPTH layout(binding = 2)
#define T_DENSE_NODE layout(binding = 5)
#define T_DENSE_MAT layout(binding = 6)

//#define FLT_MAX 3.402823466e+38F
//#define EPSILON 0.00001f
//#define PI_OVR_2 (3.1416f * 0.5f)

#define IRRADIANCE 0
#define SPECULAR_ALBEDO 1
#define NORMAL 2
#define OCCLUSION 3
#define LIGHT_DIR 4

// Buffers
U_RENDER_TYPE uniform uint renderType;
U_FETCH_LEVEL uniform uint fetchLevel;

LU_SVO_NODE buffer SVONode
{ 
	uvec4 svoNode[];
};

LU_SVO_ILLUM buffer SVOIllumination
{ 
	uvec4 svoIllum[];
};

LU_SVO_LEVEL_OFFSET buffer SVOLevelOffsets
{
	uint svoLevelOffsets[];
};

U_FTRANSFORM uniform FrameTransform
{
	mat4 view;
	mat4 projection;
};

U_INVFTRANSFORM uniform InverseFrameTransform
{
	mat4 invViewProjection;

	vec4 camPos;		// To Calculate Eye
	vec4 camDir;		// To Calculate Eye
	ivec4 viewport;		// Viewport Params
	vec4 depthNearFar;	// depth range params (last two unused)
};

U_OCTREE_UNIFORMS uniform OctreeUniforms
{
	vec3 worldPos;
	float baseSpan;

	uint minSVOLevel;
	uint denseLevel;
	uint minCascadeLevel;
	uint maxSVOLevel;
	
	uint cascadeCount;
	uint nodeOffsetDifference;
	uint gridSize;
	uint pad1;
};

// Textures
uniform I_OUT_TEXTURE image2D fbo;

uniform T_DEPTH sampler2D gBuffDepth;

// Functions
vec3 DepthToWorld(vec2 gBuffUV)
{
	// Converts Depthbuffer Value to World Coords
	// First Depthbuffer to Screen Space
	vec3 ndc = vec3(gBuffUV, texture(gBuffDepth, gBuffUV).x);
	ndc.xy = 2.0f * ndc.xy - 1.0f;
	ndc.z = ((2.0f * (ndc.z - depthNearFar.x) / (depthNearFar.y - depthNearFar.x)) - 1.0f);

	// Clip Space
	vec4 clip;
	clip.w = projection[3][2] / (ndc.z - (projection[2][2] / projection[2][3]));
	clip.xyz = ndc * clip.w;

	// From Clip Space to World Space
	return (invViewProjection * clip).xyz;
}

uint DenseIndexToLinear(in ivec3 denseIndex, in uint level)
{
	// TODO: Change to Morton (Z-order curve)
	uint size = 1 << level;
	return  denseIndex.z * size * size +
			denseIndex.y * size +
			denseIndex.x;
}

ivec3 LevelVoxId(out vec3 offset, in vec3 worldPoint, in uint depth)
{
	float levelSpan = baseSpan * (0x1 << (maxSVOLevel - depth));
	vec3 voxId = (worldPoint - worldPos.xyz) / levelSpan;
	vec3 voxIdBase = floor(voxId);
	offset = voxId - voxIdBase;
	return ivec3(voxIdBase);
}

vec3 LevelVoxIdF(in vec3 worldPoint, in uint depth)
{
	float levelSpan = baseSpan * (0x1 << (maxSVOLevel - depth));
	return (worldPoint - worldPos.xyz) / levelSpan;
}


uint CalculateLevelChildId(in ivec3 voxPos, in uint levelDepth)
{
	uint bitSet = 0;
	bitSet |= ((voxPos.z >> (maxSVOLevel - levelDepth)) & 0x000000001) << 2;
	bitSet |= ((voxPos.y >> (maxSVOLevel - levelDepth)) & 0x000000001) << 1;
	bitSet |= ((voxPos.x >> (maxSVOLevel - levelDepth)) & 0x000000001) << 0;
	return bitSet;
}

vec4 UnpackIrradianceSVO(in uint irradiancePacked)
{
	return unpackUnorm4x8(irradiancePacked);
}

vec4 UnpackOccupancySVO(in uint occupancyPacked)
{
	return unpackUnorm4x8(occupancyPacked);
}

vec3 UnpackNormalSVO(in uint normalPacked)
{
	return unpackSnorm4x8(normalPacked).xyz;
}

vec3 UnpackLightDirSVO(in uint lightDirPacked)
{
	return unpackSnorm4x8(lightDirPacked).xyz;
}

float AnisotropicOcclusion(in vec4 occlusion,
						   in vec3 direction)
{
	// TODO:
	return occlusion.x;
}

vec3 FetchFromIllum(out float occlusion, in uvec4 illum, in vec3 marchDir)
{
	// Occlusion
	vec4 occupancy = UnpackOccupancySVO(illum.z);
	occlusion = AnisotropicOcclusion(occupancy, marchDir);

	if(renderType == IRRADIANCE) return UnpackIrradianceSVO(illum.x).xyz;
	else if(renderType == SPECULAR_ALBEDO) return UnpackIrradianceSVO(illum.x).www;
	else if(renderType == NORMAL) return UnpackNormalSVO(illum.y);
	else if(renderType == OCCLUSION)
	{
		return vec3(1.0f - occlusion);
	}
	else if(renderType == LIGHT_DIR) return UnpackLightDirSVO(illum.w);
	return vec3(0.0f);
}

vec3 SampleSVO(in vec3 worldPos, in vec3 marchDir)
{
	vec3 offset;
	ivec3 voxPos = LevelVoxId(offset, worldPos, maxSVOLevel);
	ivec3 maxLevelSize = ivec3((0x1 << (cascadeCount - 1)) * gridSize);
	
	// Cull if out of bounds
	if(any(lessThan(voxPos, ivec3(0))) ||
	   any(greaterThanEqual(voxPos, maxLevelSize)))
	{
		// Node is out of bounds
		return vec3(0.0f);
	}

	// Check Dense
	if(fetchLevel >= minSVOLevel && 
	   fetchLevel <= denseLevel)
	{
		// Dense Fetch
		vec3 interp;
		uint offset = svoLevelOffsets[fetchLevel];
		ivec3 index = LevelVoxId(interp, worldPos, fetchLevel);
		uvec4 illum = svoIllum[offset + DenseIndexToLinear(index, fetchLevel)];
		
		// Data Fetch (return gray if no value is avail)
		float dataOcclusion;
		vec3 result = FetchFromIllum(dataOcclusion, illum, marchDir);
		if (dataOcclusion == 0.0f);
			result = vec3(0.25f);
		return result;
	}
	else
	{
		// Sparse Check
		// Start tracing (stateless start from root (dense))
		// Initialize Traverse
		uint nodeIndex = 0;
	
		// Dense Node Index Fetch
		vec3 interp;
		uint offset = svoLevelOffsets[denseLevel] - nodeOffsetDifference;
		ivec3 index = LevelVoxId(interp, worldPos, denseLevel);
		nodeIndex = svoNode[offset + DenseIndexToLinear(index, denseLevel)].x;

		uint traversedLevel;
		for(traversedLevel = denseLevel + 1; 
			traversedLevel <= fetchLevel;
			traversedLevel++)
		{
			if(nodeIndex == 0xFFFFFFFF && traversedLevel >= minCascadeLevel)
			   break;

			offset = svoLevelOffsets[traversedLevel] - nodeOffsetDifference;					
			nodeIndex = svoNode[offset + nodeIndex].x + CalculateLevelChildId(voxPos, traversedLevel);
		}

		if(traversedLevel >= minCascadeLevel || 
		   traversedLevel == fetchLevel)
		{
			traversedLevel--;

			offset = svoLevelOffsets[traversedLevel];					
			uvec4 illum = svoIllum[offset + nodeIndex];

			// Data Fetch (return gray if no value is avail)
			float dataOcclusion;
			vec3 result = FetchFromIllum(dataOcclusion, illum, marchDir);
			if (dataOcclusion == 0.0f);
				result = vec3(0.25f);
			return result;
		}
	}
	return vec3(0.25f);
}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main(void)
{
	// Thread Logic is per cone per pixel
	uvec2 globalId = gl_GlobalInvocationID.xy;
	uvec2 pixelId = globalId;
	if(any(greaterThanEqual(pixelId, imageSize(fbo).xy))) return;

	// Fetch GBuffer and Interpolate Positions (if size is smaller than current gbuffer)
	vec2 gBuffUV = vec2(pixelId + vec2(0.5f) - viewport.xy) / viewport.zw;
	vec3 worldPos = DepthToWorld(gBuffUV);
	vec3 marchDir = normalize(worldPos - camPos.xyz);
	
	// Actual Work
	vec3 result = SampleSVO(worldPos, marchDir);

	imageStore(fbo, ivec2(globalId), vec4(result, 0.0f));
}