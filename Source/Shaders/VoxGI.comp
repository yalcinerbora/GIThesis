#version 430
/*
	**Voxel Global Illumination Compute Shader**

	File Name	: VoxGI.comp
	Author		: Bora Yalciner
	Description	:
		Global Illumination approximation using SVO
*/

#define I_OUT_TEXTURE layout(rgba16f, binding = 0) restrict

#define LU_SVO_NODE layout(std430, binding = 2) readonly
#define LU_SVO_ILLUM layout(std430, binding = 3) readonly
#define LU_SVO_LEVEL_OFFSET layout(std430, binding = 4) readonly

#define U_CAST_SPECULAR_CONE layout(location = 3)

#define U_FTRANSFORM layout(std140, binding = 0)
#define U_INVFTRANSFORM layout(std140, binding = 1)
#define U_OCTREE_UNIFORMS layout(std140, binding = 3)
#define U_INDIRECT_UNIFORMS layout(std140, binding = 4)

#define T_COLOR layout(binding = 0)
#define T_NORMAL layout(binding = 1)
#define T_DEPTH layout(binding = 2)

#define CONE_COUNT 1
#define TRACE_NEIGBOUR 8
#define NEIGBOURS 4

#define BLOCK_SIZE_X 16
#define BLOCK_SIZE_Y 16

#define GI_LIGHT_POINT 0.0f
#define GI_LIGHT_DIRECTIONAL 1.0f
#define GI_LIGHT_AREA 2.0f

#define GI_ONE_OVER_PI 0.318309f
#define PI 3.1415f

// Uniforms
U_CAST_SPECULAR_CONE uniform uint specular;

uniform vec2 CONE_ORTHO[4] =
{
	vec2( -1.0f, -1.0f),
    vec2( -1.0f, 1.0f),
    vec2( 1.0f, -1.0f),
    vec2( 1.0f, 1.0f)
};

uniform vec4 COLORS[12] =
{
	vec4( 0 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 1 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 2 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 3 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 4 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 5 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 6 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 7 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 8 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 9 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 10 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f),
	vec4( 11 * (1.0f / 12.0f), 0.0f, 0.0f, 0.3f)
};

uniform ivec3 NEIG_MASK[8] =
{
	ivec3(0, 0, 0),
    ivec3(1, 0, 0),
    ivec3(0, 1, 0),
    ivec3(1, 1, 0),

	ivec3(0, 0, 1),
	ivec3(1, 0, 1),
	ivec3(0, 1, 1),
	ivec3(1, 1, 1)
};

LU_SVO_NODE buffer SVONode
{
	uint svoNode[];
};

LU_SVO_ILLUM buffer SVOIllumination
{
	uvec4 svoIllum[];
};

LU_SVO_LEVEL_OFFSET buffer SVOLevelOffsets
{
	uint svoLevelOffsets[];
};

U_FTRANSFORM uniform FrameTransform
{
	mat4 view;
	mat4 projection;
};

U_INVFTRANSFORM uniform InverseFrameTransform
{
	mat4 invViewProjection;

	vec4 camPos;			// To Calculate Eye
	vec4 camDir;			// To Calculate Eye
	ivec4 viewport;			// Viewport Params
	vec4 depthNearFar;		// depth range params (last two unused)
};

U_OCTREE_UNIFORMS uniform SVOConstants
{
	vec3 worldPos;
	float baseSpan;

	uint minSVOLevel;
	uint denseLevel;
	uint minCascadeLevel;
	uint maxSVOLevel;
	
	uint cascadeCount;
	uint nodeOffsetDifference;
	uint gridSize;
	uint pad1;
};

U_INDIRECT_UNIFORMS uniform ConeTraceParameters
{
	float specAngleMin;
	float specAngleMax;
	float diffAngleTanHalf;
	float sampleRatio;

	float startOffsetBias;
	float totalDistance;
	float aoIntensity;
	float giIntensity;

	float aoFalloff;
	float pading0;
	float pading1;
	float pading2;
};

// Textures
uniform I_OUT_TEXTURE image2D outTex;

uniform T_COLOR sampler2D gBuffColor;
uniform T_NORMAL usampler2D gBuffNormal;
uniform T_DEPTH sampler2D gBuffDepth;

// Functions
vec3 DepthToWorld(vec2 gBuffUV)
{
	// Converts Depthbuffer Value to World Coords
	// First Depthbuffer to Screen Space
	vec3 ndc = vec3(gBuffUV, texture(gBuffDepth, gBuffUV).x);

	ndc.xy = 2.0f * ndc.xy - 1.0f;
	ndc.z = ((2.0f * (ndc.z - depthNearFar.x) / (depthNearFar.y - depthNearFar.x)) - 1.0f);

	// Clip Space
	vec4 clip;
	clip.w = projection[3][2] / (ndc.z - (projection[2][2] / projection[2][3]));
	clip.xyz = ndc * clip.w;

	// From Clip Space to World Space
	return (invViewProjection * clip).xyz;
}

uint DenseIndexToLinear(in ivec3 denseIndex, in uint level)
{
	// TODO: Change to Morton (Z-order curve)
	uint size = 1 << level;
	return  denseIndex.z * size * size +
			denseIndex.y * size +
			denseIndex.x;
}

ivec3 LevelVoxId(out vec3 offset, in vec3 worldPoint, in uint depth)
{
	float levelSpan = baseSpan * (0x1 << (maxSVOLevel - depth));
	vec3 voxId = (worldPoint - worldPos.xyz) / levelSpan;
	vec3 voxIdBase = floor(voxId);
	offset = voxId - voxIdBase;
	return ivec3(voxIdBase);
}

vec3 LevelVoxIdF(in vec3 worldPoint, in uint depth)
{
	float levelSpan = baseSpan * (0x1 << (maxSVOLevel - depth));
	return (worldPoint - worldPos.xyz) / levelSpan;
}

vec3 VoxPosToWorld(in ivec3 voxPos, in uint depth)
{
	float levelSpan = baseSpan * (0x1 << (maxSVOLevel - depth));
	return worldPos + vec3(voxPos) * baseSpan;
}

uint DiameterToDepth(out float offset, in float diameter)
{
	float diameterRatio = diameter / baseSpan;
	if(diameterRatio < 1.0f) return maxSVOLevel;
	diameterRatio = max(diameterRatio, 1.0f);

	uint svoLevelInverse = findMSB(uint(floor(diameterRatio)));
	offset = diameterRatio - float(0x1 << svoLevelInverse);
	offset /= float(0x1 << svoLevelInverse + 1) - float(0x1 << svoLevelInverse);
	return maxSVOLevel - svoLevelInverse;
}

uint CalculateLevelChildId(in ivec3 voxPos, in uint levelDepth)
{
	uint bitSet = 0;
	bitSet |= ((voxPos.z >> (maxSVOLevel - levelDepth)) & 0x000000001) << 2;
	bitSet |= ((voxPos.y >> (maxSVOLevel - levelDepth)) & 0x000000001) << 1;
	bitSet |= ((voxPos.x >> (maxSVOLevel - levelDepth)) & 0x000000001) << 0;
	return bitSet;
}

vec3 UnpackNormalGBuff(in uvec2 norm)
{
	vec3 result;
	result.x = ((float(norm.x) / 0xFFFF) - 0.5f) * 2.0f;
	result.y = ((float(norm.y & 0x7FFF) / 0x7FFF) - 0.5f) * 2.0f;
	result.z = sqrt(abs(1.0f - dot(result.xy, result.xy)));
	result.z *= sign(int(norm.y << 16));
	return result;
}

vec4 UnpackIrradianceSVO(in uint irradiancePacked)
{
	return unpackUnorm4x8(irradiancePacked);
}

vec4 UnpackOccupancySVO(in uint occupancyPacked)
{
	return unpackUnorm4x8(occupancyPacked);
}

vec3 UnpackNormalSVO(in uint normalPacked)
{
	return unpackSnorm4x8(normalPacked).xyz;
}

vec3 UnpackLightDirSVO(in uint lightDirPacked)
{
	return unpackSnorm4x8(lightDirPacked).xyz;
}

float AnisotropicOcclusion(in vec4 occlusion,
						   in vec3 direction)
{
	// TODO:
	return occlusion.x;
}


vec4 TripolateVec4(in vec4 a,
				   in vec4 b,
				   in vec4 c,
				   in vec4 d,
				   
				   in vec4 e,
				   in vec4 f,
				   in vec4 g,
				   in vec4 h,
				   
				   in vec3 interp)
{
	vec4 x0 = mix(a, b, interp.x);
	vec4 x1 = mix(c, d, interp.x);
	vec4 x2 = mix(e, f, interp.x);
	vec4 x3 = mix(g, h, interp.x);

	vec4 y0 = mix(x0, x1, interp.y);
	vec4 y1 = mix(x2, x3, interp.y);

	return mix(y0, y1, interp.z);
}

vec3 TripolateVec3(in vec3 a,
				   in vec3 b,
				   in vec3 c,
				   in vec3 d,
				   
				   in vec3 e,
				   in vec3 f,
				   in vec3 g,
				   in vec3 h,
				   
				   in vec3 interp)
{
	vec3 x0 = mix(a, b, interp.x);
	vec3 x1 = mix(c, d, interp.x);
	vec3 x2 = mix(e, f, interp.x);
	vec3 x3 = mix(g, h, interp.x);

	vec3 y0 = mix(x0, x1, interp.y);
	vec3 y1 = mix(x2, x3, interp.y);

	return mix(y0, y1, interp.z);
}

float TripolateOcclusion(in vec4 a,
						 in vec4 b,
						 in vec4 c,
						 in vec4 d,

						 in vec4 e,
						 in vec4 f,
						 in vec4 g,
						 in vec4 h,

						 in vec3 interpValue,
						 in vec3 direction)
{
	vec4 interp = TripolateVec4(a, b, c, d,
								e, f, g, h, interpValue);

	return AnisotropicOcclusion(interp, direction);
}

void Interpolate(out vec3 lightDir,
				 out float occlusion,
				 out vec4 irradiance,
				 out vec3 normal,

				 in uvec4 matA,
				 in uvec4 matB,
				 in uvec4 matC,
				 in uvec4 matD,

				 in uvec4 matE,
				 in uvec4 matF,
				 in uvec4 matG,
				 in uvec4 matH,

				 in vec3 interpValue,
				 in vec3 direction)
{
	// Interp Irradiance
	vec4 irradA = UnpackIrradianceSVO(matA.x);
	vec4 irradB = UnpackIrradianceSVO(matB.x);
	vec4 irradC = UnpackIrradianceSVO(matC.x);
	vec4 irradD = UnpackIrradianceSVO(matD.x);
	vec4 irradE = UnpackIrradianceSVO(matE.x);
	vec4 irradF = UnpackIrradianceSVO(matF.x);
	vec4 irradG = UnpackIrradianceSVO(matG.x);
	vec4 irradH = UnpackIrradianceSVO(matH.x);

	irradiance = TripolateVec4(irradA,
							   irradB,
							   irradC,
							   irradD,
							   irradE,
							   irradF,
							   irradG,
							   irradH,

							   interpValue);


	// Interp Normal
	vec3 normalA = UnpackNormalSVO(matA.y);
	vec3 normalB = UnpackNormalSVO(matB.y);
	vec3 normalC = UnpackNormalSVO(matC.y);
	vec3 normalD = UnpackNormalSVO(matD.y);
	vec3 normalE = UnpackNormalSVO(matE.y);
	vec3 normalF = UnpackNormalSVO(matF.y);
	vec3 normalG = UnpackNormalSVO(matG.y);
	vec3 normalH = UnpackNormalSVO(matH.y);

	normal = TripolateVec3(normalA,
						   normalB,
						   normalC,
						   normalD,
						   normalE,
						   normalF,
						   normalG,
						   normalH,

						   interpValue);

	// Interp Occlusion
	vec4 occlusionA = UnpackOccupancySVO(matA.z);
	vec4 occlusionB = UnpackOccupancySVO(matB.z);
	vec4 occlusionC = UnpackOccupancySVO(matC.z);
	vec4 occlusionD = UnpackOccupancySVO(matD.z);
	vec4 occlusionE = UnpackOccupancySVO(matE.z);
	vec4 occlusionF = UnpackOccupancySVO(matF.z);
	vec4 occlusionG = UnpackOccupancySVO(matG.z);
	vec4 occlusionH = UnpackOccupancySVO(matH.z);

	occlusion = TripolateOcclusion(occlusionA,
								   occlusionB,
								   occlusionC,
								   occlusionD,
								   occlusionE,
								   occlusionF,
								   occlusionG,
								   occlusionH,
								   
								   interpValue,
								   direction);


	// Interp Light Dir
	vec3 lightDirA = UnpackLightDirSVO(matA.w);
	vec3 lightDirB = UnpackLightDirSVO(matB.w);
	vec3 lightDirC = UnpackLightDirSVO(matC.w);
	vec3 lightDirD = UnpackLightDirSVO(matD.w);
	vec3 lightDirE = UnpackLightDirSVO(matE.w);
	vec3 lightDirF = UnpackLightDirSVO(matF.w);
	vec3 lightDirG = UnpackLightDirSVO(matG.w);
	vec3 lightDirH = UnpackLightDirSVO(matH.w);

	lightDir = TripolateVec3(lightDirA,
						     lightDirB,
						     lightDirC,
						     lightDirD,
						     lightDirE,
						     lightDirF,
						     lightDirG,
						     lightDirH,
						     
						     interpValue);
}

// SVO Fetch
void SampleSVO(out vec3 lightDir,
			   out float occlusion,
			   out vec4 irradiance,
			   out vec3 normal,
			   
			   in vec3 worldPos,
			   in vec3 direction,
			   in uint sampleDepth,
			   in float depthOffset)
{

	// Double Dense Fetch
	if(sampleDepth < minSVOLevel) return;
	else if(sampleDepth >= minSVOLevel &&
		 	sampleDepth < denseLevel)
	{
		uint offsetLow = svoLevelOffsets[sampleDepth];
		uint offsetHigh = svoLevelOffsets[sampleDepth + 1];

		vec3 interpLow, interpHigh;
		ivec3 vLow = LevelVoxId(interpLow, worldPos, sampleDepth);
		ivec3 vHigh = LevelVoxId(interpHigh, worldPos, sampleDepth + 1);

		// Interp Low
		uvec4 illumLowA = svoIllum[offsetLow + DenseIndexToLinear(vLow + ivec3(0, 0, 0), sampleDepth)];
		uvec4 illumLowB = svoIllum[offsetLow + DenseIndexToLinear(vLow + ivec3(0, 0, 1), sampleDepth)];
		uvec4 illumLowC = svoIllum[offsetLow + DenseIndexToLinear(vLow + ivec3(0, 1, 0), sampleDepth)];
		uvec4 illumLowD = svoIllum[offsetLow + DenseIndexToLinear(vLow + ivec3(0, 1, 1), sampleDepth)];
																			 						 
		uvec4 illumLowE = svoIllum[offsetLow + DenseIndexToLinear(vLow + ivec3(1, 0, 0), sampleDepth)];
		uvec4 illumLowF = svoIllum[offsetLow + DenseIndexToLinear(vLow + ivec3(1, 0, 1), sampleDepth)];
		uvec4 illumLowG = svoIllum[offsetLow + DenseIndexToLinear(vLow + ivec3(1, 1, 0), sampleDepth)];
		uvec4 illumLowH = svoIllum[offsetLow + DenseIndexToLinear(vLow + ivec3(1, 1, 1), sampleDepth)];
		
		vec4 lowIrrad; vec3 lowNormal, lowLightDir; float lowOcclusion;
		Interpolate(lowLightDir, lowOcclusion, lowIrrad, lowNormal, 
					illumLowA, illumLowB, illumLowC, illumLowD,					
					illumLowE, illumLowF, illumLowG, illumLowH,					
					interpLow, 
					direction);

		// Interp High
		uvec4 illumHighA = svoIllum[offsetHigh + DenseIndexToLinear(vHigh + ivec3(0, 0, 0), sampleDepth + 1)];
		uvec4 illumHighB = svoIllum[offsetHigh + DenseIndexToLinear(vHigh + ivec3(0, 0, 1), sampleDepth + 1)];
		uvec4 illumHighC = svoIllum[offsetHigh + DenseIndexToLinear(vHigh + ivec3(0, 1, 0), sampleDepth + 1)];
		uvec4 illumHighD = svoIllum[offsetHigh + DenseIndexToLinear(vHigh + ivec3(0, 1, 1), sampleDepth + 1)];

		uvec4 illumHighE = svoIllum[offsetHigh + DenseIndexToLinear(vHigh + ivec3(1, 0, 0), sampleDepth + 1)];
		uvec4 illumHighF = svoIllum[offsetHigh + DenseIndexToLinear(vHigh + ivec3(1, 0, 1), sampleDepth + 1)];
		uvec4 illumHighG = svoIllum[offsetHigh + DenseIndexToLinear(vHigh + ivec3(1, 1, 0), sampleDepth + 1)];
		uvec4 illumHighH = svoIllum[offsetHigh + DenseIndexToLinear(vHigh + ivec3(1, 1, 1), sampleDepth + 1)];
		
		vec4 highIrrad; vec3 highNormal, highLightDir; float highOcclusion;
		Interpolate(highLightDir, highOcclusion, highIrrad, highNormal, 
					illumHighA, illumHighB, illumHighC, illumHighD,					
					illumHighE, illumHighF, illumHighG, illumHighH,					
					interpHigh, 
					direction);

		// Interp Both
		lightDir = mix(lowLightDir, highLightDir, depthOffset);
		occlusion = mix(lowOcclusion, highOcclusion, depthOffset);
		irradiance = mix(lowIrrad, highIrrad, depthOffset);
		normal = mix(lowNormal, highNormal, depthOffset);
	}
	// One Dense One SVO Fetch
	else if(false)
	{

	}
	// Double SVO Fetch
	else
	{

	}
	
	//// For each Corner Value // Offsets
	//ivec3 voxPosLevel = LevelVoxId(worldPos, fetchLevel);
	//vec3 interp = LevelVoxIdF(worldPos, fetchLevel);
	//interp -= (vec3(voxPosLevel));
	//vec3 offsets = sign(interp);

	//// Materials that will be interpolated
	//uvec4 matAB = uvec4(0);
	//uvec4 matCD = uvec4(0);
	//uvec4 matEF = uvec4(0);
	//uvec4 matGH = uvec4(0);


	//for(uint i = 0; i < ((interpolate) ? TRACE_NEIGBOUR : 1); i++)
	//{
	//	vec3 currentWorld = VoxPosToWorld(voxPosLevel + NEIG_MASK[i], fetchLevel);
	//	ivec3 voxPos = LevelVoxId(currentWorld, dimDepth.y);

	//	// Cull if out of bounds
	//	// Since cam is centered towards grid
	//	// Out of bounds means its cannot come towards the grid
	//	// directly cull
	//	if(any(lessThan(voxPos, ivec3(0))) ||
	//	   any(greaterThanEqual(voxPos, ivec3(dimDepth.x))))
	//	{
	//		uvec2 mat = uvec2(0xFF99DAF0, 0xFF000000);
	//		MatWrite(matAB, matCD, matEF, matGH, mat, i);
	//		continue;
	//	}

	//	// Initialize Traverse
	//	uint nodeIndex = 0;
	//	ivec3 denseVox = LevelVoxId(currentWorld, dimDepth.w);

	//	vec3 texCoord = vec3(denseVox) / dimDepth.z;
	//	nodeIndex = texture(tSVODense, texCoord).x;
	//	if(nodeIndex == 0xFFFFFFFF) continue;
	//	nodeIndex += CalculateLevelChildId(voxPos, dimDepth.w + 1);

	//	// Tree Traverse
	//	uint traversedLevel;
	//	for(traversedLevel = dimDepth.w + 1;
	//		traversedLevel < fetchLevel;
	//		traversedLevel++)
	//	{
	//		uint currentNode = svoNode[offsetCascade.y + svoLevelOffset[traversedLevel - dimDepth.w] + nodeIndex];
	//		if(currentNode == 0xFFFFFFFF) break;
	//		nodeIndex = currentNode + CalculateLevelChildId(voxPos, traversedLevel + 1);
	//	}

	//	// Mat out
	//	if(traversedLevel > (dimDepth.y - offsetCascade.x) ||
	//	   traversedLevel == fetchLevel)
	//	{
	//		// Mid or Leaf Level
	//		uint loc = offsetCascade.z + svoLevelOffset[traversedLevel - dimDepth.w] + nodeIndex;
	//		uvec2 mat = svoMaterial[loc].xy;
	//		MatWrite(matAB, matCD, matEF, matGH, mat, i);
	//	}
	//}

	//// Out
	//InterpolateSparse(color,
	//				  normal,

	//				  matAB,
	//				  matCD,
	//				  matEF,
	//				  matGH,

	//				  interp,
	//				  interpolate);

	//if(normal.w == 0.0f) return false;
	//return true;
}

vec3 IllumFactor(in vec3 wo,
				 in vec4 irradiance,
				 in vec3 wi,
				 in vec3 normal)
{
	float lightIntensity = 1.0f;

	float wiVariance = length(wi);
	float nVariance = length(normal);

	// Rendering Equation
	// n dot l * Surface Kd * li
	// stored in irradiance.xyz
	// voxel specular power is stored in irradiance.w
	// however we need to normalize that
	wi = normalize(wi);
	normal = normalize(normal);
	vec3 halfVec = normalize(wi + wo);
	float specPower = 16.0f + irradiance.w * 4096.0f;

	// Blinn - phong specular BRDF
	float specularBRDF = pow(max(dot(normal, halfVec), 0.0f), specPower);
	specularBRDF *= GI_ONE_OVER_PI * 0.125f * (specPower + 6.0f);
	specularBRDF /= dot(normal, wi);

	// Lambert BRDF
	float diffuseBRDF = GI_ONE_OVER_PI;

	// Total Illumination Factor
	vec3 illumination = (diffuseBRDF + specularBRDF) * irradiance.xyz;

	// Now We need to do the gaussian lobes
	// For higher levels BRDF tends to become ill defined
	// since it converges into a volume

	// TODO:
	// Light Intensity Relevant to the cone light angle (Lambert Factor)
	// Toksvig 2005
	//vec3 voxNormal = normalize(normalSVO.xyz);
	//float normalAccuracy = length(normalSVO.xyz);
	//float NDFstd2 = (1.0f - normalAccuracy) / normalAccuracy;
	//float std2 = NDFstd2 * NDFstd2 + coneStd2 * coneStd2;
	//float toksvigFactor = 1.0f / (1.0f + std2 * colorSVO.w);
	//float toksvigFactor = 1.0f;

	// Lambert Diffuse
	//lightIntensity *= pow(max(dot(voxNormal.xyz, coneDir), 0.0f), toksvigFactor);
	//lightIntensity *= (1.0f + toksvigFactor * colorSVO.w) / (1.0f + colorSVO.w);

	// Sampled Lobe Factor
	//lightIntensity *= normalSVO.w;
	//lightIntensity *= (1.0f - normalSVO.w);
	//lightIntensity *= ((1.0f - lobeFactor) / lobeFactor);

	//return lightIntensity * colorSVO.xyz;// * GI_ONE_OVER_PI;
	//return abs(voxNormal.xyz) * 2.0f;//0.005f;

	return illumination;
}

vec3 CalculateConeOffset(in vec3 ortho1, in vec3 ortho2, float angleRadian)
{
	return normalize(ortho1 * cos(angleRadian) + ortho2 * sin(angleRadian));
}

void GenOrthoBasis(out vec3 ortho1, out vec3 ortho2, in vec3 vector)
{
	// Find an Arbitrary orthogonal basis
	// set min abs component to 1
	vec3 absVector = abs(vector);
	float axisMin = min(absVector.x, min(absVector.y, absVector.z));
	vec3 vecOrtho = vec3((absVector.x == axisMin) ? 1.0f : vector.x,
						 (absVector.y == axisMin) ? 1.0f : vector.y,
						 (absVector.z == axisMin) ? 1.0f : vector.z);
	ortho1 = normalize(cross(vector, vecOrtho));
	ortho2 = normalize(cross(vector, ortho1));

	// [(-z-y) / x, 1, 1] is perpendicular (unless normal is X axis)
	// handle special case where normal is (1.0f, 0.0f, 0.0f)
	// = normalize(vec3(-(worldNorm.z + worldNorm.y) / worldNorm.x, 1.0f, 1.0f));
	//ortho1 = mix(ortho1, vec3(0.0f, 1.0f, 0.0f), floor(worldNorm.x));
	//vec3 ortho2 = normalize(cross(worldNorm, ortho1));
}

layout (local_size_x = BLOCK_SIZE_X, local_size_y = BLOCK_SIZE_Y, local_size_z = 1) in;
void main(void)
{
	// Thread Logic is per cone per pixel
	uvec2 globalId = gl_GlobalInvocationID.xy;
	if(any(greaterThanEqual(globalId, imageSize(outTex).xy))) return;

	// Fetch GBuffer and Interpolate Positions (if size is smaller than current gbuffer)
	vec2 gBuffUV = vec2(globalId + vec2(0.5f) - viewport.xy) / viewport.zw;
	vec3 pos = DepthToWorld(gBuffUV);
	vec3 worldNorm = UnpackNormalGBuff(texture(gBuffNormal, gBuffUV).xy);

	// Determine cascade no from distance of the camera
	// And the min span for that cascade
	vec3 gridCenter = worldPos + baseSpan * gridSize * (0x1 << (cascadeCount - 1));
	vec3 diff = abs(pos - gridCenter) / float(gridSize / 2);
	float maxDiff = max(diff.x, max(diff.y, diff.z));
	uint cascade = max(0, findMSB(uint(maxDiff)));
	float cascadeSpan = baseSpan * float(0x1 << cascade);

	// Specular cone
	// Angle
	float specularity = texture(gBuffColor, gBuffUV).a;
	float specConeAngle = specAngleMin + specularity * (specAngleMax - specAngleMin);
	float specConeAperture = tan(specConeAngle * 0.5f);
	// Direction
	vec3 worldEye = normalize(camPos.xyz - pos);
	vec3 specConeDir = normalize(-reflect(worldEye, worldNorm));
	bool skipSpec = specularity < 0.5f;

	// Diffuse Cone
	// Determine Diffuse Cone ID (multiple Neigbours Fetch Different Cones then gets blurred)
	uint dirId = ((globalId.x  % (NEIGBOURS / 2)) * (NEIGBOURS / 2)) + (globalId.y % (NEIGBOURS / 2));

	// Find Edge vectors from normal
	vec3 ortho1, ortho2;
	GenOrthoBasis(ortho1, ortho2, worldNorm);

	float diffuseConeAperture = diffAngleTanHalf;
	vec3 coneOffset = CalculateConeOffset(ortho1, ortho2, dirId * (2.0f * PI / NEIGBOURS));
	vec3 diffuseConeDir = normalize(worldNorm + diffuseConeAperture * coneOffset);

	// Everything is generated now cone tracing
	// Single specular cone and single diffuse cone
	vec4 surfaceAccumulation = vec4(0.0f);
	uint coneCount = (specular == 0) ? CONE_COUNT : CONE_COUNT + 1;
	for(uint i = 0; i < coneCount; i++)
	{
		// Chose the cone
		float coneAperture = (i != CONE_COUNT) ? diffuseConeAperture : specConeAperture;
		vec3 coneDir = (i != CONE_COUNT) ? diffuseConeDir : specConeDir;
		if(skipSpec && i == CONE_COUNT) continue;

		// Initally Start the cone away from the surface since
		// voxel system and polygon system are not %100 aligned
		vec3 initalTraceStart = pos + worldNorm * cascadeSpan * startOffsetBias;

		// Total Illumination and Occlusion
		vec3 totalIllumination = vec3(0.0f);
		float totalAO = 0.0f;
		float totalOcclusion = 0.0f;

		// Start sampling towards that direction
		// Loop Traverses until MaxDistance Exceeded
		// March distance is variable per iteration
		float marchDistance = cascadeSpan;
		for(float traversedDistance = 0.0f;
			traversedDistance <= totalDistance;
			traversedDistance += marchDistance)
		{
			vec3 currentPos = initalTraceStart + coneDir * traversedDistance;
			float diameter = max(cascadeSpan, coneAperture * traversedDistance * 2.0f);

			// Sample from SVO (Quadlinear Interpolation)
			vec4 irradiance = vec4(0.0f);
			vec3 normal = vec3(0.0f), lightDir = vec3(0.0f);
			float occlusion = 0.0f, depthOffset = 0.0f;
			uint sampleDepth = DiameterToDepth(depthOffset, diameter);
			SampleSVO(lightDir, occlusion, irradiance, normal,
					  currentPos, coneDir, 
					  sampleDepth, depthOffset);

			// Calculate Illumination
			vec3 illumination = IllumFactor(coneDir,
											irradiance,
											lightDir,
											normal);

			// Correction Term to prevent intersecting samples error
			occlusion = 1.0f - pow(1.0f - occlusion, marchDistance / diameter);
			illumination = vec3(1.0f) - pow(vec3(1.0f) - illumination, vec3(marchDistance / diameter));

			// Occlusion falloff (linear)
			float falloff = (1.0f / (1.0f + aoFalloff * diameter));
			//float falloff = (1.0f / (1.0f + aoFalloff * diameter));
			//float falloff = (1.0f / (1.0f + aoFalloff * traversedDistance));

			// Incorporation
			//float factor = (i == CONE_COUNT) ? 1.0f : 4.0f;
			illumination *= dot(worldNorm, coneDir);
			//nodeOcclusion *= dot(worldNorm, coneDir);

			// Volume Occlusion Sampling
			totalIllumination += (vec3(1.0f) - totalOcclusion) * illumination;
			if(i != CONE_COUNT) totalAO = (1.0f - totalOcclusion) * occlusion * falloff;
			totalOcclusion += (1.0f - totalOcclusion) * occlusion;			

			// Advance sample point (from sampling diameter)
			marchDistance = diameter * sampleRatio;

			// Break on early occlusion
			if(abs(totalOcclusion - 1.0f) < 0.001f) break;
		}
		// Add contrubution of this vec
		surfaceAccumulation.xyz += totalIllumination;
		surfaceAccumulation.w += totalOcclusion;
	}
	// Intensity incorporation
	surfaceAccumulation.xyz *= giIntensity;
	surfaceAccumulation.w *= aoIntensity;
	surfaceAccumulation.w = 1.0f - surfaceAccumulation.w;

	// All Done!
	//imageStore(outTex, ivec2(globalId), color);
	//imageStore(outTex, ivec2(globalId), vec4(diffuseConeDir, 0.0f));
	imageStore(outTex, ivec2(globalId), surfaceAccumulation);
	//imageStore(outTex, ivec2(globalId), vec4(result.w));
	//imageStore(outTex, ivec2(globalId), vec4(pos, 0.0f));
	//imageStore(outTex, ivec2(globalId), vec4(worldNorm, 0.0f));
}
