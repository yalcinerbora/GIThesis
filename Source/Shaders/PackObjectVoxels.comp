#version 430
				
// Definitions
#define LU_VOXEL_POS layout(std430, binding = 0) restrict
#define LU_VOXEL_NORM layout(std430, binding = 1) restrict
#define LU_VOXEL_COLOR layout(std430, binding = 2) restrict 
#define LU_INDEX_CHECK layout(std430, binding = 4) restrict

#define LU_NORMAL_DENSE layout(std430, binding = 6) restrict readonly
#define LU_COLOR_DENSE layout(std430, binding = 7) restrict readonly

#define I_LOCK layout(r32ui, binding = 0) restrict readonly

#define U_OBJ_ID layout(location = 4)
#define U_MAX_CACHE_SIZE layout(location = 5)
#define U_OBJ_TYPE layout(location = 6)
#define U_SPLIT_CURRENT layout(location = 7)
#define U_TEX_SIZE layout(location = 8)
#define U_IS_MIP layout(location = 9)

// I-O
U_OBJ_TYPE uniform uint objType;
U_OBJ_ID uniform uint objId;
U_IS_MIP uniform uint isMip;
U_MAX_CACHE_SIZE uniform uint maxSize;
U_SPLIT_CURRENT uniform uvec3 currentSplit;
U_TEX_SIZE uniform uvec4 texSize3D;

uniform I_LOCK uimage3D lock;

LU_INDEX_CHECK buffer CountArray
{
	uint writeIndex;
};

LU_VOXEL_POS buffer VoxelPosArray
{
	uint voxelPos[];
};

LU_VOXEL_NORM buffer VoxelNormArray
{
	uint voxelNorm[];
};

LU_VOXEL_COLOR buffer VoxelArrayColor
{
	uint voxColor[];
};

LU_COLOR_DENSE buffer ColorBuffer 
{
	vec4 colorDense[];
};

LU_NORMAL_DENSE buffer NormalBuffer 
{
	vec4 normalDense[];
};

uint PackVoxelPos(in uvec3 voxCoord)
{
	// Voxel Ids 10 Bit Each (last 2 bit will be used for cascade no)
	uint result = 0;
	result |= voxCoord.z << 20;
	result |= voxCoord.y << 10;
	result |= voxCoord.x;
	return result;
}

uvec2 PackVoxelIds(in uint objId,
				   in uint objType,
				   in uint renderDataLoc)
{
	uvec2 result = uvec2(0);

	// Object Id (13 bit batch id, 16 bit object id)
	// Last 2 bits is for object type
	uint value = 0;
	value |= objType << 30;
	value |= 0 << 16;
	value |= objId;
	result.x = value;

	result.y = renderDataLoc;
	return result;
}

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main(void)
{
	uvec3 voxId = gl_GlobalInvocationID.xyz;
	if(voxId.x < texSize3D.x &&
	   voxId.y < texSize3D.y &&
	   voxId.z < texSize3D.z)
	{
		ivec3 iCoord = ivec3(voxId);
		uint coord = iCoord.z * texSize3D.w * texSize3D.w +
					 iCoord.y * texSize3D.w +
					 iCoord.x;
		
		vec4 normal = normalDense[coord];
		vec4 color = colorDense[coord];

		// Empty Normal Means its vox is empty
		if(normal.w > 0.0f)
		{
			// Average Divide
			color.xyz /= normal.w;
			normal.xyz /= normal.w;
			normal.w = 0.0f;

			uint index = atomicAdd(writeIndex, 1);
			if(index <= maxSize)
			{
				voxId += currentSplit * texSize3D.w;

				voxColor[index] = packUnorm4x8(color);
				voxelNorm[index] = packSnorm4x8(normal);
				voxelPos[index] = PackVoxelPos(voxId);
			}
		}
	}
}