#version 430
/*	
	**Voxel Deferred Sampled Compute Shader**
	
	File Name	: VoxTraceAO.vert
	Author		: Bora Yalciner
	Description	:

		Instead of tracing camera rays it directly samples deferred depth buffer to
		Sample positions from depth buffer
*/

// Definitions
#define I_OUT_TEXTURE layout(rgba16f, binding = 0) restrict writeonly

#define LU_SVO_NODE layout(std430, binding = 2) readonly
#define LU_SVO_ILLUM layout(std430, binding = 3) readonly
#define LU_SVO_LEVEL_OFFSET layout(std430, binding = 4) readonly

#define U_RENDER_TYPE layout(location = 0)
#define U_FETCH_LEVEL layout(location = 1)

#define U_FTRANSFORM layout(std140, binding = 0)
#define U_INVFTRANSFORM layout(std140, binding = 1)
#define U_OCTREE_UNIFORMS layout(std140, binding = 3)

#define T_DEPTH layout(binding = 2)

#define IRRADIANCE 0
#define SPECULAR_ALBEDO 1
#define NORMAL 2
#define OCCLUSION 3
#define LIGHT_DIR 4

// Buffers
U_RENDER_TYPE uniform uint renderType;
U_FETCH_LEVEL uniform uint fetchLevel;

LU_SVO_NODE buffer SVONode
{ 
	uvec4 svoNode[];
};

LU_SVO_ILLUM buffer SVOIllumination
{ 
	uvec4 svoIllum[];
};

LU_SVO_LEVEL_OFFSET buffer SVOLevelOffsets
{
	uint svoLevelOffsets[];
};

U_FTRANSFORM uniform FrameTransform
{
	mat4 view;
	mat4 projection;
};

U_INVFTRANSFORM uniform InverseFrameTransform
{
	mat4 invViewProjection;

	vec4 camPos;		// To Calculate Eye
	vec4 camDir;		// To Calculate Eye
	ivec4 viewport;		// Viewport Params
	vec4 depthNearFar;	// depth range params (last two unused)
};

U_OCTREE_UNIFORMS uniform OctreeUniforms
{
	vec3 worldPos;
	float baseSpan;

	uint minSVOLevel;
	uint denseLevel;
	uint minCascadeLevel;
	uint maxSVOLevel;
	
	uint cascadeCount;
	uint nodeOffsetDifference;
	uint gridSize;
	uint pad0;
};

// Textures
uniform I_OUT_TEXTURE image2D fbo;

uniform T_DEPTH sampler2D gBuffDepth;

// Functions
vec3 DepthToWorld(vec2 gBuffUV)
{
	// Converts Depthbuffer Value to World Coords
	// First Depthbuffer to Screen Space
	vec3 ndc = vec3(gBuffUV, texture(gBuffDepth, gBuffUV).x);
	if(ndc.z == 1.0f) return vec3(1.0e+10);

	ndc.xy = 2.0f * ndc.xy - 1.0f;
	ndc.z = ((2.0f * (ndc.z - depthNearFar.x) / (depthNearFar.y - depthNearFar.x)) - 1.0f);

	// Clip Space
	vec4 clip;
	clip.w = projection[3][2] / (ndc.z - (projection[2][2] / projection[2][3]));
	clip.xyz = ndc * clip.w;

	// From Clip Space to World Space
	return (invViewProjection * clip).xyz;
}

uint DenseIndexToLinear(in ivec3 denseIndex, in uint level)
{
	// TODO: Change to Morton (Z-order curve)
	uint size = (0x1 << level);
	return  denseIndex.z * size * size +
			denseIndex.y * size +
			denseIndex.x;
}

ivec3 LevelVoxId(out vec3 offset, in vec3 worldPoint, in uint depth)
{
	float levelSpan = baseSpan * (0x1 << (maxSVOLevel - depth));
	vec3 voxId = (worldPoint - worldPos.xyz) / levelSpan;
	vec3 voxIdBase = floor(voxId);
	offset = voxId - voxIdBase;
	return ivec3(voxIdBase);
}

//vec3 LevelVoxIdF(in vec3 worldPoint, in uint depth)
//{
//	float levelSpan = baseSpan * (0x1 << (maxSVOLevel - depth));
//	return (worldPoint - worldPos.xyz) / levelSpan;
//}

uint CalculateLevelChildId(in ivec3 voxPos, in uint level)
{
	uint bitSet = 0;
	bitSet |= ((voxPos.z >> (maxSVOLevel - level)) & 0x000000001) << 2;
	bitSet |= ((voxPos.y >> (maxSVOLevel - level)) & 0x000000001) << 1;
	bitSet |= ((voxPos.x >> (maxSVOLevel - level)) & 0x000000001) << 0;
	return bitSet;
}

vec4 UnpackIrradianceSVO(in uint irradiancePacked)
{
	return unpackUnorm4x8(irradiancePacked);
}

vec4 UnpackOccupancySVO(in uint occupancyPacked)
{
	return unpackUnorm4x8(occupancyPacked);
}

vec3 UnpackNormalSVO(in uint normalPacked)
{
	return unpackSnorm4x8(normalPacked).xyz;
}

vec3 UnpackLightDirSVO(in uint lightDirPacked)
{
	return unpackSnorm4x8(lightDirPacked).xyz;
}

float AnisotropicOcclusion(in vec4 occlusion,
						   in vec3 direction)
{
	// TODO:
	return occlusion.x;
}

vec3 FetchFromIllum(out float occlusion, in uvec4 illum, in vec3 marchDir)
{
	// Occlusion
	vec4 occupancy = UnpackOccupancySVO(illum.z);
	occlusion = AnisotropicOcclusion(occupancy, marchDir);

	if(renderType == IRRADIANCE) return UnpackIrradianceSVO(illum.x).xyz;
	else if(renderType == SPECULAR_ALBEDO) return UnpackIrradianceSVO(illum.x).www;
	else if(renderType == NORMAL) return (UnpackNormalSVO(illum.y) + 1.0f) * 0.5f;
	else if(renderType == OCCLUSION) return vec3(1.0f - occlusion);
	else if(renderType == LIGHT_DIR) return (UnpackLightDirSVO(illum.w) + 1.0f) * 0.5f;
	return vec3(0.0f);
}

vec3 SampleSVO(in vec3 worldPos, in vec3 marchDir)
{
	vec3 offset;
	ivec3 voxPos = LevelVoxId(offset, worldPos, maxSVOLevel);
	ivec3 maxLevelSize = ivec3(0x1 << maxSVOLevel);
	
	// Cull if out of bounds
	//if(any(lessThan(voxPos, ivec3(0))) ||
	//   any(greaterThanEqual(voxPos, maxLevelSize)))
	if(	voxPos.x < 0 || voxPos.x >= maxLevelSize.x ||
		voxPos.y < 0 || voxPos.y >= maxLevelSize.y ||
		voxPos.z < 0 || voxPos.z >= maxLevelSize.z)
	{
		// Node is out of bounds
		return vec3(0.0f);
	}

	// Check Dense
	if(fetchLevel >= minSVOLevel && 
	   fetchLevel <= denseLevel)
	{
		// Dense Fetch
		vec3 interp;
		ivec3 index = LevelVoxId(interp, worldPos, fetchLevel);
		uint offset = svoLevelOffsets[fetchLevel];
		uvec4 illum = svoIllum[offset + DenseIndexToLinear(index, fetchLevel)];
		
		// Data Fetch (return gray if no value is avail)
		float dataOcclusion;
		vec3 result = FetchFromIllum(dataOcclusion, illum, marchDir);
		//if (dataOcclusion == 0.0f) vec3(1.0f, 0.0f, 1.0f);
		return result;
	}
	else
	{
		// Sparse Check
		// Start tracing (stateless start from root (dense))
		// Initialize Traverse	
		// Dense Node Index Fetch
		vec3 interp;
		ivec3 index = LevelVoxId(interp, worldPos, denseLevel);
		uint nodeIndex = DenseIndexToLinear(index, denseLevel);

		uint traversedLevel = denseLevel;
		while(traversedLevel < fetchLevel)
		{			
			uint offset = svoLevelOffsets[traversedLevel] - nodeOffsetDifference;
			uint nextNode = svoNode[offset + nodeIndex].x;
			if(nextNode == 0xFFFFFFFF) break;
			
			traversedLevel++;
			nodeIndex = nextNode + CalculateLevelChildId(voxPos, traversedLevel);
		}

		// Fetch data if either we are on traversed level
		// or missed but on cascade level		 
		if(traversedLevel >= minCascadeLevel || 
		   traversedLevel == fetchLevel)
		{
			uint offset = svoLevelOffsets[traversedLevel];					
			uvec4 illum = svoIllum[offset + nodeIndex];

			// Data Fetch (return gray if no value is avail)
			float dataOcclusion;
			vec3 result = FetchFromIllum(dataOcclusion, illum, marchDir);
			if (dataOcclusion == 0.0f) result = vec3(1.0f, 0.0f, 1.0f);
			return result;
		}
	}
	return vec3(0.0f, 1.0f, 1.0f);
}

float LinearDepth(float depthLog)
{
	float n = depthNearFar.x;
	float f = depthNearFar.y;
	return (2 * n) / (f + n - depthLog * (f - n));
}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main(void)
{
	// Thread Logic is per cone per pixel
	uvec2 globalId = gl_GlobalInvocationID.xy;
	if(any(greaterThanEqual(globalId, imageSize(fbo).xy))) return;

	// Fetch GBuffer and Interpolate Positions (if size is smaller than current gbuffer)
	vec2 gBuffUV = vec2(globalId + vec2(0.5f) - viewport.xy) / viewport.zw;
	vec3 worldPos = DepthToWorld(gBuffUV);
	vec3 marchDir = normalize(worldPos - camPos.xyz);
	
	// Actual Work
	vec3 result = SampleSVO(worldPos, marchDir);
	imageStore(fbo, ivec2(globalId), vec4(result, 1.0f));
		
	//uint linearId = globalId.y * imageSize(fbo).x + globalId.x;
	//uint offset = svoLevelOffsets[9];		
	//uint irradiance = svoIllum[offset + linearId].x;
	//uint node = svoNode[offset - nodeOffsetDifference + linearId].x;
	////if(linearId < 737792)
	////if(linearId < (64*64*64))
	//if(linearId < 100 * 1024)
	//{
	//	if(node != 0xFFFFFFFF) imageStore(fbo, ivec2(globalId), vec4(1.0f));
	//	else imageStore(fbo, ivec2(globalId), vec4(0.0f));

	//	//imageStore(fbo, ivec2(globalId), UnpackIrradianceSVO(irradiance));
	//}
	//else
	//{
	//	imageStore(fbo, ivec2(globalId), vec4(0.0f, 1.0f, 0.33f, 0.0f));
	//}
}